#!/usr/bin/env python3\n"""\nStatic Code Review Test Suite - Concise Version\nEssential tests for code quality analysis.\n"""\n\nimport ast\nimport os\nimport re\nimport tempfile\nfrom pathlib import Path\nfrom typing import Dict, List, Set, Any\nfrom collections import defaultdict\n\nimport pytest\n\n\nclass CodeQualityChecker:\n    """Simplified code quality checker for template validation."""\n\n    def __init__(self, repo_path: str):\n        self.repo_path = Path(repo_path)\n        self.issues = []\n\n    def check_file(self, file_path: Path) -> List[Dict[str, Any]]:\n        """Check a single file for quality issues."""\n        issues = []\n\n        try:\n            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                content = f.read()\n                lines = content.splitlines()\n\n            # Basic checks\n            issues.extend(self._check_syntax(file_path, content))\n            issues.extend(self._check_style(file_path, lines))\n            issues.extend(self._check_security(file_path, content))\n\n        except Exception:\n            pass\n\n        return issues\n\n    def _check_syntax(self, file_path: Path, content: str) -> List[Dict[str, Any]]:\n        """Check syntax errors."""\n        issues = []\n\n        if file_path.suffix == '.py':\n            try:\n                ast.parse(content)\n            except SyntaxError as e:\n                issues.append({\n                    'file': str(file_path),\n                    'type': 'syntax_error',\n                    'severity': 'critical',\n                    'line': e.lineno,\n                    'message': str(e)\n                })\n\n        return issues\n\n    def _check_style(self, file_path: Path, lines: List[str]) -> List[Dict[str, Any]]:\n        """Check basic style issues."""\n        issues = []\n\n        for i, line in enumerate(lines, 1):\n            if len(line.rstrip()) > 120:\n                issues.append({\n                    'file': str(file_path),\n                    'type': 'line_too_long',\n                    'severity': 'low',\n                    'line': i,\n                    'message': f'Line too long ({len(line.rstrip())} > 120 characters)'\n                })\n\n        return issues\n\n    def _check_security(self, file_path: Path, content: str) -> List[Dict[str, Any]]:\n        """Check basic security issues."""\n        issues = []\n\n        # Only check actual source files, not test files\n        if 'test' in str(file_path).lower():\n            return issues\n\n        patterns = [\n            (r'password\s*=\s*["\'][^"\']+["\']', 'hardcoded_password'),\n            (r'api_key\s*=\s*["\'][^"\']+["\']', 'hardcoded_api_key'),\n        ]\n\n        for pattern, issue_type in patterns:\n            matches = re.finditer(pattern, content, re.IGNORECASE)\n            for match in matches:\n                line_num = content[:match.start()].count('\\n') + 1\n                issues.append({\n                    'file': str(file_path),\n                    'type': issue_type,\n                    'severity': 'critical',\n                    'line': line_num,\n                    'message': f'Potential {issue_type.replace("_", " ")} detected'\n                })\n\n        return issues\n\n    def scan_repository(self) -> Dict[str, Any]:\n        """Scan the repository for issues."""\n        all_issues = []\n        files_scanned = 0\n\n        for root, dirs, files in os.walk(self.repo_path):\n            # Skip certain directories\n            dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__', '.venv']]\n\n            for file in files:\n                if file.endswith(('.py', '.js', '.ts')):\n                    file_path = Path(root) / file\n                    issues = self.check_file(file_path)\n                    all_issues.extend(issues)\n                    files_scanned += 1\n\n        # Categorize issues\n        by_severity = defaultdict(int)\n        for issue in all_issues:\n            by_severity[issue['severity']] += 1\n\n        return {\n            'files_scanned': files_scanned,\n            'total_issues': len(all_issues),\n            'issues_by_severity': dict(by_severity),\n            'issues': all_issues\n        }\n\n\nclass TestCodeQuality:\n    """Test suite for code quality checking."""\n\n    def setup_method(self):\n        """Setup for each test method."""\n        self.repo_path = os.getcwd()\n        self.checker = CodeQualityChecker(self.repo_path)\n\n    def test_checker_initialization(self):\n        """Test that checker initializes correctly."""\n        assert self.checker.repo_path == Path(self.repo_path)\n        assert self.checker.issues == []\n\n    def test_syntax_checking(self):\n        """Test syntax checking functionality."""\n        # Create a temporary Python file with syntax error\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n            f.write('def broken_function(\\n    pass')  # Missing closing parenthesis\n            temp_file = Path(f.name)\n\n        try:\n            issues = self.checker.check_file(temp_file)\n            syntax_issues = [i for i in issues if i['type'] == 'syntax_error']\n            assert len(syntax_issues) > 0\n            assert syntax_issues[0]['severity'] == 'critical'\n        finally:\n            os.unlink(temp_file)\n\n    def test_style_checking(self):\n        """Test style checking functionality."""\n        # Create a temporary file with style issues\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n            long_line = 'x = ' + 'a' * 120  # Create a line longer than 120 characters\n            f.write(long_line)\n            temp_file = Path(f.name)\n\n        try:\n            issues = self.checker.check_file(temp_file)\n            style_issues = [i for i in issues if i['type'] == 'line_too_long']\n            assert len(style_issues) > 0\n        finally:\n            os.unlink(temp_file)\n\n    def test_repository_scan(self):\n        """Test full repository scanning."""\n        report = self.checker.scan_repository()\n\n        # Verify report structure\n        assert 'files_scanned' in report\n        assert 'total_issues' in report\n        assert 'issues_by_severity' in report\n        assert 'issues' in report\n\n        # Should have scanned some files\n        assert report['files_scanned'] > 0\n\n\ndef test_template_repository_quality():\n    """Integration test: Check template repository quality."""\n    checker = CodeQualityChecker('.')\n    report = checker.scan_repository()\n\n    print("\\n=== Repository Quality Report ===")\n    print(f"Files scanned: {report['files_scanned']}")\n    print(f"Total issues: {report['total_issues']}")\n\n    if report['issues_by_severity']:\n        print("Issues by severity:")\n        for severity, count in report['issues_by_severity'].items():\n            print(f"  {severity}: {count}")\n\n    # Template should have minimal critical issues in source code\n    source_critical = len([i for i in report['issues']\n                          if i['severity'] == 'critical' and 'src/' in i['file']])\n\n    print(f"Critical issues in source code: {source_critical}")\n\n    # Assert that source code has no critical issues\n    assert source_critical == 0, f"Source code should have no critical issues, found {source_critical}"\n\n\nif __name__ == "__main__":\n    # Run the integration test directly\n    test_template_repository_quality()\n\n